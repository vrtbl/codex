<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Passerine Codex</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> A Short Preface</a></li><li class="chapter-item expanded "><a href="road-ahead.html"><strong aria-hidden="true">2.</strong> The Road Ahead</a></li><li class="chapter-item expanded "><a href="getting-started/getting-started.html"><strong aria-hidden="true">3.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">3.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">3.2.</strong> Hello, World!</a></li></ol></li><li class="chapter-item expanded "><a href="core/core.html"><strong aria-hidden="true">4.</strong> The Core Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="core/syntax.html"><strong aria-hidden="true">4.1.</strong> Syntax</a></li><li class="chapter-item expanded "><a href="core/a-quick-example.html"><strong aria-hidden="true">4.2.</strong> A Quick(sort) Example</a></li><li class="chapter-item expanded "><a href="core/function-application.html"><strong aria-hidden="true">4.3.</strong> Function Application</a></li><li class="chapter-item expanded "><a href="core/pattern-matching.html"><strong aria-hidden="true">4.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="core/fibers.html"><strong aria-hidden="true">4.5.</strong> Fibers</a></li><li class="chapter-item expanded "><a href="core/error-handling.html"><strong aria-hidden="true">4.6.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="core/macros.html"><strong aria-hidden="true">4.7.</strong> Macros</a></li><li class="chapter-item expanded "><a href="core/match-from-scratch.html"><strong aria-hidden="true">4.8.</strong> Match From Scratch</a></li><li class="chapter-item expanded "><a href="core/modules.html"><strong aria-hidden="true">4.9.</strong> Modules</a></li></ol></li><li class="chapter-item expanded "><a href="concluding-thoughts.html"><strong aria-hidden="true">5.</strong> Concluding Thoughts</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">6.</strong> Frequently Asked Questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Passerine Codex</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-passerine-codex"><a class="header" href="#the-passerine-codex">The Passerine Codex</a></h1>
<p><em>An Extensive Overview of Passerine</em></p>
<h2 id="foreword"><a class="header" href="#foreword">Foreword</a></h2>
<p><em>By Isaac Clayton</em></p>
<p>Passerine is in an early stage of development, so it's hard to pin down exactly what it will become. In this respect, we have a single point on the wall: as there are a lot of lines that can be drawn through a point, there are a lot of different directions this language could take.</p>
<p>So in the following foreword, I would like to lay out my history with computers, and discuss what I've come to learn about them. Through this, I hope to put another metaphorical 'point on the wall': Two points form a line, of course, and I'm hoping the the line drawn by this codex and the code we have now will be enough to find the 'figure in the marble' and chisel out the rest of Passerine.</p>
<p>Too heavy on the metaphor? Probably.</p>
<p>I first thought of developing a programming language for myself when I was around 12 or 13. At the time, I had just stumbled across lisp, having learned Python a few years before (by working through Downey's <em>Think Python</em>). I was quite enthralled by the possibilities lisp opened in my mind: if programs are sets of transformations on data (<em>Functional Programming</em>), and the programs themselves are just data (<em>Metaprogramming</em>), what can't we create? Wanting to learn more, I learned Common Lisp (through <em>On Lisp</em>), and them Scheme (through the <em>Wizard Book</em>, which I'm still particularly fond of).</p>
<p>So, with lisp on my mind, I wrote one. It was nothing more than a toy, of course—A thin veneer of a language tacked onto Norvig's <em>Scheme in Python</em>—but it was a language nonetheless.</p>
<p>Lisp, of course, is more a category of languages than a single standard; the featureless landscape of parenthesis, while beautiful in all its symmetries, lacks the benefit concise notation brings. I extended the small lisp I wrote earlier into a language called <em>Aspen</em>: a small scheme with inferred parenthesis and richer syntax. This endeavor was simplistic at best—I felt I had exhausted most of what lisp had to offer for me at that time—</p>
<p>So I moved onto other languages. I juggled pointers with C, categorized with Haskell, tore apart data structures with OCaml, threw exceptions with Java (then threw Java out the window), marched fractals in GLSL, beamed messages around with Erlang and Elixir, reinforced agents in Python; this is just the tip of the iceberg. Languages were the tools I used to rip through the universe of computation, exposing new corners for breaking down abstractions, if only to build them back up a bit more airtight later, perhaps. Once you begin to understand how one language maps to another—everything old being new again—minimal languages that exemplify a core aspect of computation stand out above the rest.</p>
<p>The brilliance of lisp stems from the fact that it is, at its core, a LISt Processing language. Everything in lisp is built as a graph of <code>cons</code>—list cells. Because the abstract syntax tree (AST) of the language itself is nested lists of lists, and lisp is a language <em>built</em> around easily manipulating lists, it's no wonder that lisp's macro system is so powerful. Lisp is specifically built for manipulating lists, and lisp itself is lists!</p>
<p>One thing that I think is viewed incorrectly about lisps, though, is <em>homoiconicity</em>, or at least the usual way the word is interpreted. After all, <em>Homoiconicity isn’t the point</em>. </p>
<p>For a metaprogramming system to be powerful, the language representation should match the representation that the language itself is designed to manipulate. Lisp's macro system is powerful because lisp is <em>designed</em> to operate on lists.</p>
<p>What matters in a metaprogramming system is selecting a language representation that the language is built to manipulate. Lisp seems to be one of the only languages to get this right. Lists, however, are <em>not</em> the best tool for modeling a wide range of structures and behaviors. </p>
<p>Data should be presented in the simplest form that still preserves visual uniqueness. The semantic operators that determine how the underlying data is processed should be distinctive enough to easily be recognizable and actionable:</p>
<blockquote>
<p>&quot;[This engages] the brain's visual processing machinery, which operates largely subconsciously, and tells the consciousness part of what it sees.&quot;</p>
<p>— Guido van Rossum</p>
</blockquote>
<p>If what matters in metaprogramming is self-representation, then requiring everything to share the same syntax—as lisp does—seems a tad counterproductive. Our brains come equipped with rich built-in visual processors: by having code and data appear to be the same, it's hard to get a feel for what the code is doing by examining the shape of it.</p>
<p>Abstract data types (ADTs)—structs and enums—are a much richer way to represent data, and ergo programming languages. As lisp is built on the axioms of list processing, MLs (as in Standard ML &amp; OCaml) are built on the axioms of ADTs: pattern matching, type inference, construction.</p>
<p>I guess I find it a little surprising, then, that lisp-style macro systems built on manipulating ADTs are uncommon in ML-style languages. It seems like the natural next step after lisp. Lisp is built for manipulating lists and has a powerful macro system built on it. ADTs are richer than lists, ML is built for manipulating ADTs — wouldn't an ML macro system built on ADTs rival lisp's expressive power?</p>
<p>Languages are, after all, just tools to express computation: no matter how hard we try, there will never be a language that won't make us clarify our ideas.</p>
<p>But we <em>can</em>, at the very least, build languages that make those ideas easier to express.</p>
<p>About two years ago now (as of 2020), I stumbled across Rust (I was 14 at the time). Rust opened my mind yet again to another world of possibilities. Ownership and borrowing allow us to express fine-grained control over <em>resources</em>. Being functional yet imperative, Rust also challenged my assumptions about what it meant to follow a paradigm. In the words of Saoirse:</p>
<blockquote>
<p>Pure functional programming is an ingenious trick to show you can code without mutation. Rust is an even cleverer trick to show you can just have mutation.</p>
<p>— Saoirse (withoutboats)</p>
</blockquote>
<p>Rust is now my preferred programming language. I'm not going to wax poetic and tell you that it's the best language in existence, but it's certainly a very <em>very</em> nice one. Although it may be superficially complex, it's conceptually elegant (and I mean that in the best way possible). More importantly, the community that has developed around Rust is exceptional, and I'm grateful for the interactions I've had (and have yet to have had) with the Rust community.</p>
<p>Now, what does any of this have to do with Passerine?</p>
<p>Designing a language without taking inspiration from others is a fool's errand. I hope I've shown you the path I have followed to reach the point where I'm at now. Making a programming language is a bit like making a soup: take a little of everything, let it simmer for a while, and serve it while it's hot.</p>
<p>So: over the past few years or so, an idea for a novel programming language has been simmering in my mind. This language is the compounded framework of ideas I've developed since I've started programming, boiled down to a refined core.</p>
<p>This language, of course, is Passerine: a small core language that is easily extensible, with roots in Scheme and ML-flavored languages. Above all else, Passerine is the tool I've always wished I had. I find it to be useful for me, and I hope that it will be useful for you too.</p>
<p>— Isaac Clayton (slightknack)</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-road-ahead"><a class="header" href="#the-road-ahead">The Road Ahead</a></h2>
<p><img src="https://cdn.aarp.net/content/dam/aarp/home-and-family/family-and-friends/2018/05/1140-utah-road-trip-planning.imgcache.revc8d3f86f90c6edc63fc2b92a8a311a72.jpg" alt="A winding mountain desert road thing, much like the journey we're about to have!" /></p>
<p>This codex is organized into a bunch of sections. Each section builds on the last. By the end, you should have a pretty good picture of what Passerine is, and what it aspires to be.</p>
<p>We'll start by exploring the language the functional foundations on which Passerine is build. We'll then work towards patterns of building up and tearing data.</p>
<p>With the core in place, it's time so shift gears. We'll rip through Passerine's trait and effect systems, and learn that - maybe - they're not so different after all. We'll also discuss how types and effects can be composed for greater control over the runtime and execution environment.</p>
<p>With that sprint behind us, we'll then take a short detour, and chat about modules and package management. Here you'll meet aspen, and get some real dirt under your nails as we write a few projects together.</p>
<p>With practical experience under our belts, some hidden patterns will slowly become obvious. In the final section of this Codex, we'll dive deep into the heart of macros and compile-time evaluation, and leverage the ultimate abstraction to bend Passerine to our will. If that doesn't sound crazy, I don't know what is!</p>
<p>It's going to be a wild ride, dear reader, so you'd better buckle up!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this chapter, we will install Passerine and run a simple program to ensure that everything is working.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Passerine is still very much so a work in progress. We've done a lot, but there's still a so much more to do!</p>
<p>For you pioneers out there, The best way to get a feel for Passerine is to install <a href="https://github.com/vrtbl/aspen">Aspen</a>¹, Passerine's package manager and CLI.</p>
<p>If you use a *nix-style² system, run³:</p>
<pre><code class="language-bash">sh &lt;(curl -sSf https://www.passerine.io/install.sh)
</code></pre>
<blockquote>
<ol>
<li>If you're having trouble getting started, reach out on the community <a href="https://discord.gg/yMhUyhw">Discord server</a>.</li>
<li>Tested on Arch (btw) and macOS.</li>
<li>Now tested on Windows™!</li>
<li>(Also, <em>experimentally</em> supports Wasm.)</li>
<li>In the future, we plan to distribute prebuilt binaries, but for now, both Git and Cargo are required.</li>
</ol>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="hello-world"><a class="header" href="#hello-world">Hello, world!</a></h2>
<p>Let's test our installation!</p>
<p>Open up a terminal and create a new Passerine project in a directory called <code>hello_world</code> by running:</p>
<pre><code>$ aspen new hello_world
</code></pre>
<blockquote>
<p>Alternatively, you can run <code>aspen new</code> to create a new project in the current directory.</p>
</blockquote>
<p>Enter the directory, and open <code>main.pn</code> using your favorite IDE or text editor.</p>
<p>You should see:</p>
<pre><code>println &quot;Hello, Passerine!&quot;
</code></pre>
<p>You can execute this file in the terminal by running:</p>
<pre><code>$ aspen run
</code></pre>
<p>You should see the output:</p>
<pre><code>Hello, Passerine
</code></pre>
<p>Now, let's move on to the core language!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-core-language"><a class="header" href="#the-core-language">The Core Language</a></h1>
<p>In this chapter, we will take a look at the core language features offered by Passerine.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Comment from @zack466:
    While I like this introduction, it might be a little confusing for beginners.
    Beginners might not know what functions, tuples, etc are yet.
-->
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>The goal of Passerine's syntax is to make all expressions as <em>concise</em> as possible while still conserving the 'feel' of <em>different types</em> of expressions.</p>
<p>We'll start simple; here's a function that squares a number:</p>
<pre><code class="language-elm">square = x -&gt; x * x
square 4 -- is 16
</code></pre>
<blockquote>
<p>By the way: Passerine uses <code>-- comment</code> for single-line comments and <code>-{ comment }-</code> for nestable multi-line comments.</p>
</blockquote>
<p>There are already some important things we can learn about Passerine from this short example:</p>
<p>Like other programming languages, Passerine uses <code>=</code> for assignment. On the left hand side is a <em>pattern</em> – in this case, just the variable <code>square</code> – which destructures an expression into a set of bindings. On the right hand side is an <em>expression</em>; in this case the expression is a <em>function definition</em>.</p>
<blockquote>
<p>Because Passerine is <em>expression-oriented</em>, the distinction between statements and expressions isn't made. In the case that an expression produces no useful value, it should return the Unit type, <code>()</code>. Assignment, for instance, returns Unit.</p>
</blockquote>
<p>The function call <code>square 4</code> may look a bit alien to you; this is because Passerine uses whitespace for function calls. A function call takes the form <code>l e₀ ... eₙ</code>, where <code>l</code> is a function and <code>e</code> is an expression. <code>square 4</code> is a simple case because <code>square</code> only takes one argument, <code>x</code>... let's try writing a function that takes two arguments!</p>
<p>Using our definition of <code>square</code>, here's a function that returns the Euclidean distance between two points:</p>
<pre><code class="language-elm">distance = (x1, y1) (x2, y2) -&gt; {
    sqrt (square (x1 - x2) + square (y1 - y2))
}

origin = (0, 0)
distance origin (3, 4) -- is 5
</code></pre>
<p>Passerine is an <em>expression-oriented</em> language, because of this, it makes sense that <em>all functions are anonymous</em>. All functions take the form <code>p₀ ... pₙ -&gt; e</code>, where <code>p</code> is a pattern and <code>e</code> is an expression. If a function takes multiple arguments, they can be written one after another; <code>a b c -&gt; d</code> is equivalent to <code>a -&gt; (b -&gt; (c -&gt; d))</code>.</p>
<p>The function <code>distance</code> is a bit more complex that <code>square</code>, because the two arguments are bound using <em>tuple destructuring</em>.</p>
<p>As you can see, <code>distance</code> takes two pairs, <code>(x1, y1)</code> and <code>(x2, y2)</code>, and <em>destructures</em> each pair into its component parts. For instance, when we call <code>distance</code> in <code>distance origin (3, 4)</code> the function pulls out the numbers that make up the pair:</p>
<ul>
<li><code>origin</code>, i.e. <code>(0, 0)</code>, is matched against <code>(x1, y1)</code>, creating the bindings <code>x1 = 0</code> and <code>y1 = 0</code>.</li>
<li>the tuple <code>(3, 4)</code> is matched against <code>(x2, y2)</code>, creating the bindings <code>x2 = 3</code> and <code>y2 = 4</code>.</li>
</ul>
<p>The body of <code>distance</code>, <code>sqrt (...)</code> is then evaluated in a new scope where the variables defined about are bound. In the case of the above example:</p>
<pre><code class="language-elm">-- call and bind
distance origin (3, 4)
distance (0, 0) (3, 4)

-- substitute and evaluate
sqrt (square (0 - 3) + square (0 - 4))
sqrt (9 + 5)
sqrt 25
5
</code></pre>
<p>Now, you may have noticed that <code>distance</code> is actually two functions. It may be more obvious it we remove some syntactic sugar rewrite it like so:</p>
<pre><code class="language-elm">distance = (x1, y1) -&gt; { (x2, y2) -&gt; { ... } }
</code></pre>
<p>The first function binds the first argument, then returns a new function that binds the second argument, which evaluates to a value. This is known as <em>currying</em>, and can be really useful when writing functional code.</p>
<blockquote>
<p>To leverage currying, function calls are <em>left-associative</em>. The call <code>a b c d</code> is equivalent to <code>((a b) c) d</code>, not <code>a (b (c d))</code>. This syntax comes from functional languages like Haskell and OCaml, and makes currying (partial application) quite intuitive.</p>
</blockquote>
<p>In the above example, we used <code>distance</code> to measure how far away <code>(3, 4)</code> was from the origin. Coincidentally, this is known as the <em>length</em> of a vector. Wouldn't it be nice if we could define length in terms of distance?</p>
<pre><code class="language-elm">length = distance origin
length (5, 12) -- is 13
</code></pre>
<p>Because distance is curried, we can call it with only one of its arguments. For this reason, <code>length</code> is a function that takes a pair and returns its distance from the <code>origin</code>. In essence, we can read the above definition of <code>length</code> as:</p>
<blockquote>
<p><code>length</code> is the <code>distance</code> from <code>origin</code>.</p>
</blockquote>
<p>Transforming data through the use of and functions and pattern matching is a central paradigm of Passerine. In the following sections, we'll dive deep and show how this small core language is enough to build a powerful and flexible language.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="a-quick-sort-example"><a class="header" href="#a-quick-sort-example">A Quick(-sort) Example</a></h2>
<p>Here's another slightly more complex example – a recursive quick-sort with questionable pivot selection:</p>
<pre><code class="language-elm">sort = list -&gt; match list {
    -- base case
    [] -&gt; []

    -- pivot is head, tail is remaining
    [pivot, ..tail] -&gt; {
        higher = filter { x -&gt; x &gt;= pivot } tail
        lower  = filter { x -&gt; x &lt;  pivot } tail

        (sorted_lower, sorted_higher) = (sort lower, sort higher)

        sorted_lower
            + [pivot]
            + sorted_higher
    }
}
</code></pre>
<p>The first thing that you should notice is the use of a <code>match</code> expression. Like ML-style languages, Passerine makes extensive use of <em>pattern matching</em> and <em>destructuring</em> as a driver of computation. A match expression takes the form:</p>
<pre><code class="language-elm">match value {
    pattern₀ -&gt; expression₀
    ...
    patternₙ -&gt; expressionₙ
}
</code></pre>
<p>Each <code>pattern -&gt; expression</code> pair is a <em>branch</em> – each <code>value</code> is against each branch in order until a branch successfully matches and evaluates – the match expression takes on the value of the matching branch. We'll take a deep dive into match statements <a href="core/a-quick-example.html#building-a-match-expression">later</a>, so keep this in mind.</p>
<p>You might've also noticed the use of curly braces <code>{ ... }</code> after <code>[head, ..tail]</code>. This is a <em>block</em>, a group of expressions executed one after another. Each expression in a block is separated by a newline or semicolon; the block takes on the value of its last expression.</p>
<p>The next thing to notice is this line:</p>
<pre><code class="language-elm">(sorted_lower, sorted_higher) = (sort lower, sort higher)
</code></pre>
<p>This is a more complex assignment than the first one we saw. In this example, the pattern <code>(sorted_lower, sorted_higher)</code> is being matched against the expression <code>(sort lower, sort higher)</code>. This pattern is a <em>tuple</em> destructuring, if you've ever used Python or Rust, I'm sure you're familiar with it. This assignment is equivalent to:</p>
<pre><code class="language-elm">sorted_lower  = sort lower
sorted_higher = sort higher
</code></pre>
<p>There's no real reason to use tuple destructuring here – idiomatically, just using <code>sort lower</code> and <code>sort higher</code> is the better solution. We discuss pattern matching in depth in the <a href="core/a-quick-example.html#pattern-matching">next section</a>.</p>
<p>Passerine also supports higher order functions (this should come as no surprise):</p>
<pre><code class="language-elm">filter { x -&gt; x &gt;= pivot } tail
</code></pre>
<p><code>filter</code> takes a predicate (a function) and an iterable (like a list), and produces a new iterable where the predicate is true for all items. Although parenthesis could be used to group the inline function definition after <code>filter</code>, it's stylistically more coherent to use blocks for <em>regions of computation</em>. What's a region of computation? A region of computation is a series of multiple expressions, or a single expression that creates new bindings, like an assignment or a function definition.</p>
<p>Passerine also allows lines to be split around operators to break up long expressions:</p>
<pre><code class="language-elm">sorted_lower
    + [pivot]
    + sorted_higher
</code></pre>
<p>Although this is not a particularly long expression, splitting up lines by operations can help improve the legibility of some expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="function-application"><a class="header" href="#function-application">Function Application</a></h2>
<p>Before we move on, here's a clever implementation of FizzBuzz in Passerine:</p>
<pre><code class="language-elm">fizzbuzz = n -&gt; {
    test = d s x
        -&gt; if n % d == 0 {
            _ -&gt; s + x &quot;&quot;
        } else { x }

    fizz = test 3 &quot;Fizz&quot;
    buzz = test 5 &quot;Buzz&quot;
    &quot;{n}&quot; . fizz (buzz (i -&gt; i))
}

1..100 . fizzbuzz . print
</code></pre>
<p><code>.</code> is the function application operator:</p>
<pre><code class="language-elm">-- the composition
a . b c . d

-- is left-associative
(a . (b c)) . d

-- and equivalent to
d ((b c) a)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>In the last section, we touched on pattern matching a little. I hope to now go one step further and build a strong argument as to why pattern matching in Passerine is such a powerful construct. Patterns are used in in three places:</p>
<ol>
<li>Assignments,</li>
<li>Functions,</li>
<li>and Type Definitions.</li>
</ol>
<p>We'll briefly discuss each type of pattern and the context in which they are used.</p>
<h3 id="what-are-patterns"><a class="header" href="#what-are-patterns">What are patterns?</a></h3>
<p><em>Patterns</em> extract <em>data</em> from <em>types</em> by mirroring the structure of those types. The act of applying a pattern to a type is called <em>matching</em> or <em>destructuring</em> – when a pattern matches some data successfully, a number of <em>bindings</em> are produced.</p>
<p>Passerine supports algebraic data types, and all of these types can be matched and destructured against. Here is a table of Passerine's patterns:</p>
<blockquote>
<p>In the following table, <code>p</code> is a nested sub-pattern.</p>
</blockquote>
<table><thead><tr><th>pattern</th><th>example</th><th>destructures</th></tr></thead><tbody>
<tr><td>variable</td><td><code>foo</code></td><td>Terminal pattern, binds an variable to a value.</td></tr>
<tr><td>data</td><td><code>420.69</code></td><td>Terminal pattern,  data that <em>must</em> match, raises an error otherwise. See the following section on fibers and concurrency to get an idea of how errors work in Passerine.</td></tr>
<tr><td>discard</td><td><code>_</code></td><td>Terminal pattern, matches any data, does not produce a binding.</td></tr>
<tr><td>label</td><td><code>Baz p</code></td><td>Matches a label, i.e. a named <em>type</em> in Passerine.</td></tr>
<tr><td>tuple</td><td><code>(p₀, ...)</code></td><td>Matches each element of a tuple, which is a group of elements, of potentially different types. Unit <code>()</code> is the empty tuple.</td></tr>
<tr><td>list</td><td><code>[]</code>/<code>[p₀, ..p₁]</code></td><td><code>[]</code> Matches an empty list - <code>p₀</code> matches the head of a list, <code>..p₁</code> matches the tail.</td></tr>
<tr><td>record</td><td><code>{f₀: p₀, ...}</code></td><td>A record, i.e. a struct. This is a series of field-pattern pairs. If a field does not exist in the target record, an error is raised.</td></tr>
<tr><td>enum</td><td><code>{p₀; ...}</code></td><td>An enumeration, i.e. a union. Matches if any of the patterns hold.</td></tr>
<tr><td>is</td><td><code>p₀: p₁</code></td><td>A type annotation. Matches against <code>p₀</code> only if <code>p₁</code> holds, errors otherwise.</td></tr>
<tr><td>where</td><td><code>p \| e</code></td><td>A bit different from the other patterns so far. Matches <code>p</code> only if the expression <code>e</code> is true.</td></tr>
</tbody></table>
<p>That's quite a lot of information, so let's work through it. The simplest case is a standard assignment:</p>
<pre><code class="language-elm">a = b
-- produces the binding a = b
</code></pre>
<p>This is very straightforward and we've already covered this, so let's begin by discussing matching against <em>data</em>. The following function will return the second argument if the first argument passed to the function is <code>true</code>.</p>
<pre><code class="language-elm">true second -&gt; second
</code></pre>
<p>If the first argument is not true, say <code>false</code>, Passerine will yell at us:</p>
<pre><code>Fatal Traceback, most recent call last:
In src/main.pn:1:1
   |
 1 | (true second -&gt; second) false &quot;Bananas!&quot;
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
In src/main.pn:1:2
   |
 1 | (true second -&gt; second) false &quot;Bananas!&quot;
   |  ^^^^
   |
Runtime Pattern Matching Error: The data 'false' does not match the expected data 'true'
</code></pre>
<p><em>Discard</em> is another simple pattern – it does nothing. It's most useful when used in conjunction with other patterns:</p>
<pre><code class="language-elm">-- to ensure an fruit has the type Banana:
banana: Banana _ = mystery_fruit

-- to ignore an item in a tuple:
(_, plays_tennis, height_in_feet) = (&quot;Juan Milan&quot;, true, 27.5)

-- to ignore a field on a record:
{ name: &quot;Isaac Clayton&quot;, age: _, skill } = isaac
</code></pre>
<p>A <em>label</em> is a name given to a type. Of course, names do not imply type safety, but they do do a darn good job most of the time:</p>
<pre><code class="language-elm">-- make a soft yellow banana:
banana = Banana (&quot;yellow&quot;, &quot;soft&quot;)

-- check that the banana flesh is soft:
if { Banana (_, flesh) = banana; flesh == &quot;soft&quot; } {
    print &quot;Delicioso!&quot;
}
</code></pre>
<p>Pattern matching on labels is used to <em>extract</em> the raw data that is used to construct that label.</p>
<p><em>Tuples</em> are fairly simple – we already covered them – so we'll cover records next. A record is a set of fields:</p>
<pre><code class="language-elm">-- define the Person type
type Person {
    name:  String,
    age:   Natural,
    skill, -- polymorphic over skill
}

-- Make a person. It's me!
isaac = Person {
    name:  &quot;Isaac Clayton&quot;,
    age:   16,
    skill: Wizard &quot;High enough ¯\_(ツ)_/¯&quot;,
}
</code></pre>
<p>Here's how you can pattern match on <code>isaac</code>:</p>
<pre><code class="language-elm">Person {
    -- aliasing field `name` as `full_name`
    name: full_name,
    -- `age` is ignored
    age: _,
    -- short for `skill: skill`
    skill,
} = isaac
</code></pre>
<p>Of course, the pattern after the field is a full pattern, and can be matched against further.</p>
<p><em>Is</em> is a type annotation:</p>
<pre><code>Banana (color, _): Banana (_, &quot;soft&quot;) = fruit
</code></pre>
<p>In this example, <code>color</code> will be bound if <code>fruit</code> is a <code>Banana</code> whose 1nd† tuple item is <code>&quot;soft&quot;</code>.</p>
<blockquote>
<p>† Read as 'firnd', corresponds to the 1-indexed <em>second</em> item. Zerost, firnd, secord, thirth, fourth, fifth...</p>
</blockquote>
<p>Finally, we'll address my favorite pattern, <em>where</em>. Where allows for arbitrary code check the validity of a pattern. This can go a long way. For example, let's define natural numbers in terms of integers:</p>
<pre><code class="language-elm">type Natural n: Integer | n &gt;= 0
</code></pre>
<p>This should be interpreted as:</p>
<blockquote>
<p>The type <code>Natural</code> is an <code>Integer</code> <code>n</code> where <code>n</code> is greater than <code>0</code>.</p>
</blockquote>
<p>With this definition in place:</p>
<pre><code class="language-elm">-- this is valid
seven = Natural 7

-- this is not
negative_six = Natural -6
</code></pre>
<p>Where clauses in patterns ensure that the underlying data of a type can never break an invariant. As you can imagine, this is more powerful than ensuring name-safety through type constructors.</p>
<blockquote>
<p>TODO: traits and impls.</p>
</blockquote>
<p>Pattern matching and algebraic data types allow for quickly building up and tearing down expressive data schemas. As data (and the transformation applied to it) are the core of any program, constructs for quickly building up and tearing down complex datatypes are an incredible tool for scripting expressive applications.</p>
<div style="break-before: page; page-break-before: always;"></div><!-- Comment from @zack466
I switched around the Fibers/Exceptions sections so fibers weren't split up.
-->
<h2 id="fibers"><a class="header" href="#fibers">Fibers</a></h2>
<p>What do prime sieves, exceptions, and for-loops have in common? If you guessed concurrency, you won a bajillion points! Structured concurrency is a difficult problem to tackle, given how pervasive it is in the field language design.</p>
<p>It's important to point out that concurrency is <em>not</em> the same thing as parallelism. Concurrent systems may be parallel, but that's not always the case. Passerine subscribes to the coroutine model of structured concurrency – more succinctly, Passerine uses <em>fibers</em> – as exemplified by <a href="https://wren.io">Wren</a>. A fiber is a lightweight process of execution that is cooperatively scheduled with other fibers. Each fiber is like a little system unto itself that can pass messages to other fibers.</p>
<blockquote>
<p>TODO: Algebraic Effects?</p>
</blockquote>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<!-- Fibers are for more than just isolating the context of errors. As mentioned earlier: -->
<blockquote>
<p>A fiber is a lightweight process of execution that is cooperatively scheduled with other fibers. Each fiber is like a little system unto itself that can pass messages to other fibers.</p>
</blockquote>
<!-- Passerine leverages fibers to handle errors, but fibers are full *coroutines*. -->
<p>To create a fiber, use the fiber keyword:</p>
<pre><code class="language-elm">counter = fiber {
    i = 0
    loop { yield i; i = i + 1 }
}

print counter () -&gt; prints 0
print counter () -&gt; prints 1
print counter () -&gt; ...
</code></pre>
<p>The <code>yield</code> keyword suspends the current fiber and returns a value to the calling fiber. <code>yield</code> can also be used to pass data <em>into</em> a fiber.</p>
<pre><code class="language-elm">passing_yield = fiber {
    print &quot;hello&quot;
    result = yield &quot;banana&quot;
    print result
    &quot;yes&quot;
}

passing_yield &quot;first&quot;  -- prints &quot;hello&quot; then evaluates to &quot;banana&quot;
passing_yield &quot;second&quot; -- prints &quot;second&quot; then evaluates to &quot;yes&quot;
passing_yield &quot;uh oh&quot;  -- raises an error, fiber is done
</code></pre>
<p>To build more complex systems, you can build fibers with functions:</p>
<pre><code class="language-elm">-- a function that returns a fiber
flopper = this that -&gt; fiber {
    loop {
        yield this
        yield that
    }
}

apple_banana = flopper &quot;Apple&quot; &quot;Banana&quot;

apple_banana () -- evaluates to &quot;Apple&quot;
apple_banana () -- evaluates to &quot;Banana&quot;
apple_banana () -- evaluates to &quot;Apple&quot;
apple_banana () -- ... you get the point
</code></pre>
<p>Of course, the possibilities are endless.</p>
<p>In addition, fibers, while usually being ran in the context of another, all act as peers to each-other. If you have a reference to a fiber, it's possible to transfer to it forgetting the context in which it was called. To switch to a fiber, use <code>switch</code>.</p>
<pre><code class="language-elm">banana_and_end = fiber {
    print &quot;banana ending!&quot;
}

print &quot;the beginning...&quot;
switch banana_and_end
print &quot;the end.&quot;
</code></pre>
<p><code>&quot;the end.&quot;</code> is never displayed.</p>
<blockquote>
<p>'Tis not the end, 'tis but the beginning... 'tis hackin' time!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>Passerine uses a combination of <em>exceptions</em> and algebraic data types to handle errors. Errors that are expected to happen should be wrapped in a <code>Result</code> type:</p>
<pre><code class="language-elm">validate_length = n -&gt; {
    if length n &lt; 5 {
        Result.Error &quot;It's too short!&quot;
    } else {
        Result.Ok n
    }
}
</code></pre>
<p>Some errors, however, are unexpected. There are an uncountable number of ways software can fail; to account for all external circumstances is flat-out impossible in some cases.</p>
<p>For this reason, in the case that something that isn't expected to fail fails, an exception is raised. For example, trying to open a file that <em>should</em> exist may throw an error if it has been lost, moved, corrupted, or otherwise has incorrect permissions.</p>
<pre><code class="language-elm">config = Config.parse (open &quot;config.toml&quot;)
</code></pre>
<blockquote>
<p><code>.</code> is the indexing operator. On a list or tuple, <code>items.0</code> returns the zerost item; on a record, <code>record.field</code> returns the specified field; <strong>on a label, <code>Label.method</code> returns the specified associated method</strong>.</p>
</blockquote>
<p>The reason we don't always need to handle these errors is because Passerine follows a fail-fast, fail-safe philosophy. In this regard, Passerine subscribes to the philosophy of Erlang/Elixir:</p>
<blockquote>
<p>&quot;Keep calm and let it crash.&quot;</p>
</blockquote>
<p>The good news is that crashes are local to the fiber they occur in – a single fiber crashing does <em>not</em> bring down the whole system. The idiomatic way to handle an operation that we know may fail is to try it. <code>try</code> performs the operation in a new fiber and converts any exceptions that may occur into a <code>Result</code>:</p>
<pre><code class="language-elm">config = match try (open &quot;config.toml&quot;) {
    Result.Ok    file  -&gt; Config.parse file
    Result.Error error -&gt; Config.default ()
}
</code></pre>
<p>We know that some functions may raise errors, but how can <em>we</em> signal that something exceptionally bad has happened? We use the <code>error</code> keyword!</p>
<pre><code class="language-elm">doof = platypus -&gt; {
    if platypus == &quot;Perry&quot; {
        -- crashes the current fiber
        error &quot;What!? Perry the platypus!?&quot;
    } else {
        -- oh, it's just a platypus...
        work_on_inator ()
    }
}

-- oh no!
inator = doof &quot;Perry&quot;
</code></pre>
<p>Note that the value of raised errors can be any data. This allows for programmatic recovery from errors:</p>
<pre><code class="language-elm">-- socket must not be disconnected
send_data = (
    socket
    data
) -&gt; match socket.connection {
    -- `Disconnected` is a labeled record
    Option.None -&gt; error Disconnected {
        socket,
        message: &quot;Could not send data; disconnected&quot;,
    }
    -- if the connection is open, we send the data
    Option.Some connection -&gt; connection.write data
}
</code></pre>
<p>Let's say the above code tries to send some data through a socket. To handle a disconnection, we can try the error:</p>
<pre><code class="language-elm">ping = socket -&gt; try (send_data socket &quot;ping&quot;)

socket = Socket.new &quot;isaac@passerine.io:42069&quot; -- whatever
socket.disconnect () -- oh no!

result = ping socket

match result {
    Result.Ok &quot;pong&quot; -&gt; ()
    Result.Error Disconnected socket -&gt; socked.connect
}
</code></pre>
<p>Why make the distinction between expected errors (<code>Result</code>) and unexpected errors (fiber crashes)? Programs only produce valid results if the environments they run in are valid. When a fiber crashes, it's signaling that something about the environment it's running in is not valid. This is very useful to <em>developers</em> during development, and very useful to <em>programs</em> in contexts where complex long-running applications may fail for any number of reasons.</p>
<p>Why not only use exceptions then? Because it's perfectly possible for an error to occur that is not exceptional at all. Malformed input, incorrect permissions, missing items – these are all things that can occur and do occur on a regular basis. It's always important to use the right tool for the job; prefer expected errors over unexpected errors.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="macros"><a class="header" href="#macros">Macros</a></h2>
<p>Passerine has a rich hygienic* syntactic macro system that extends the language itself.</p>
<p><em>Syntactic macros</em>, quite simply, are bits of code that <em>hygienically</em> produce more code when invoked at compile time. Macros use a small, simple-yet-powerful set of rules to transform code.</p>
<blockquote>
<p>* Having read Doug Hoyte's exellent <a href="https://letoverlambda.com/">Let Over Lambda</a>, I understand the raw power of a rich <em>unhygenic</em> macro system. However, such systems are hard to comprehend, and harder to master. Passerine aims to be as simple and powerful as possible without losing <em>transparency</em>: hygienic macro systems are much more transparent then their opaque unhygenic counterparts.</p>
</blockquote>
<h3 id="hygiene"><a class="header" href="#hygiene">Hygiene</a></h3>
<p>Extensions are defined with the <code>syntax</code> keyword, followed by some <em>argument patterns</em>, followed by the code that the captured arguments will be spliced into. Here's a simple example: we're using a macro to define <code>swap</code> operator:</p>
<pre><code class="language-elm">syntax a 'swap b {
    tmp = a
    a = b
    b = tmp
}

x = 7
y = 3
x swap y
</code></pre>
<p>Note that the above code is completely hygienic. the expanded macro looks something like this:</p>
<pre><code class="language-elm">_tmp = x
x = y
x = _tmp
</code></pre>
<p>Because <code>tmp</code> was not passed as a macro pattern parameter, all uses of <code>tmp</code> in the macro body are unique unrepresentable variables that do not collide with any other variables currently bound in scope. Essentially:</p>
<pre><code class="language-elm">tmp = 1
x = 2
y = 3
x swap y
</code></pre>
<p>Will not affect the value of <code>tmp</code>; <code>tmp</code> will still be <code>1</code>.</p>
<h4 id="argument-patterns"><a class="header" href="#argument-patterns">Argument Patterns</a></h4>
<p>So, what is an argument pattern (an <em>arg-pat</em>)? Arg-pats are what go between:</p>
<pre><code class="language-elm">syntax ... { }
</code></pre>
<p>Each item between <code>syntax</code> and the macro body is an arg-pat. Arg-pats can be:</p>
<ul>
<li><em>Syntactic variables</em>, like <code>foo</code> and <code>bar</code>.</li>
<li>Literal <em>syntactic identifiers</em>, which are prefixed with a quote (<code>'</code>), like <code>'let</code>.</li>
<li>Nested argument patterns, followed by optional <em>modifiers</em>.</li>
</ul>
<p>Let's start with <em>syntactic identifiers</em>. Identifiers are literal names that must be present for the pattern to match. Each syntactic extension is required to have at least one. For example, here's a macro that matches a <em>for loop</em>:</p>
<pre><code class="language-elm">syntax 'for binding 'in values do { ... }
</code></pre>
<p>In this case, <code>'for</code> and <code>'in</code> are syntactic identifiers. This definition could be used as follows:</p>
<pre><code class="language-elm">for a in [1, 2, 3] {
    print a
}
</code></pre>
<p><em>Syntactic variables</em> are the other identifiers in the pattern that are bound to actual values. In the above example, <code>a</code> → <code>binding</code>, <code>[1, 2, 3]</code> → <code>values</code>, and <code>{ print a }</code> → <code>do</code>.</p>
<p>Macros can also be used to define operators†:</p>
<pre><code class="language-elm">syntax sequence 'contains value {
    c = seq -&gt; match seq {
        [] -&gt; False
        [head, ..] | head == value -&gt; True
        [_, ..tail] -&gt; c tail
    }

    c sequence
}
</code></pre>
<p>This defines a <code>contains</code> operator that could be used as follows:</p>
<pre><code class="language-elm">print {
    if [1, 2, 3] contains 2 {
        &quot;It contains 2&quot;
    } else {
        &quot;It does not contain 2&quot;
    }
}
</code></pre>
<p>Evidently, <code>It contains 2</code> would be printed.</p>
<blockquote>
<p>† Custom operators defined in this manner will always have the lowest precedence, and must be explicitly grouped when ambiguous. For this reason, Passerine already has a number of built-in operators (with proper precedence) which can be overloaded. It's important to note that macros serve to introduce new constructs that just <em>happen</em> to be composable – syntactic macros can be used to make custom operators, but they can be used for <em>so much more</em>. I think this is a fair trade-off to make.</p>
</blockquote>
<p><em>Modifiers</em> are postfix symbols that allow for flexibility within argument patterns. Here are some modifiers:</p>
<ul>
<li>Zero or more (<code>...</code>)</li>
<li>Optional (<code>?</code>)</li>
</ul>
<p>Additionally, parenthesis are used for grouping, and <code>{ ... }</code> are used to match expressions within blocks. Let's construct some syntactic arguments that match an <code>if else</code> statement, like this one:</p>
<pre><code class="language-elm">if x == 0 {
    print &quot;Zero&quot;
} else if x % 2 == 0 {
    print &quot;Even&quot;
} else {
    print &quot;Not even or zero&quot;
}
</code></pre>
<p>The arg-pat must match a beginning <code>if</code>:</p>
<pre><code class="language-elm">syntax 'if { ... }
</code></pre>
<p>Then, a condition:</p>
<pre><code class="language-elm">syntax 'if condition { ... }
</code></pre>
<p>Then, the first block:</p>
<pre><code class="language-elm">syntax 'if condition then { ... }
</code></pre>
<p>Next, we'll need a number of <code>else if &lt;condition&gt;</code> statements:</p>
<pre><code class="language-elm">syntax 'if condition then ('else 'if others do)... { ... }
</code></pre>
<p>Followed by a required closing else (Passerine is expression oriented and type-checked, so a closing <code>else</code> ensures that an <code>if</code> expression always returns a value.):</p>
<pre><code class="language-elm">syntax 'if condition then ('else 'if others do)... 'else finally { ... }
</code></pre>
<p>Of course, if statements are already baked into the language – let's build something else – a <code>match</code> expression.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="building-a-match-expression"><a class="header" href="#building-a-match-expression">Building a <code>match</code> expression</a></h2>
<p>A match expression takes a value and a number of functions, and tries to apply the value to each function until one successfully matches and runs. A match expression looks as like this:</p>
<pre><code class="language-elm">l = Some (1, 2, 3)

match l {
    Some (m, x, b) -&gt; m * x + b
    None           -&gt; 0
}
</code></pre>
<p>Here's how we can match a match expression:</p>
<pre><code class="language-elm">syntax 'match value { arms... } {
    -- TODO: implement the body
}
</code></pre>
<p>This should be read as:</p>
<blockquote>
<p>The syntax for a match expression starts with the pseudokeyword <code>match</code>, followed by the <code>value</code> to match against, followed by a block where each item in the block gets collected into the list <code>arms</code>.</p>
</blockquote>
<p>What about the body? Well:</p>
<ol>
<li>If no branches are matched, an error is raised.</li>
<li>If are some branches, we <code>try</code> the first branch in a new fiber and see if it matches.</li>
<li>If the function doesn't raise a match error, we found a match!</li>
<li>If the function does raise a match error, we try again with the remaining branches.</li>
</ol>
<p>Let's start by implementing this as a function:</p>
<pre><code class="language-elm">-- takes a value to match against
-- and a list of functions, branches
match_function = value branches -&gt; {
    if branches.is_empty {
        error Match &quot;No branches matched in match expression&quot;
    }

    result = try { (head branches) value }

    if result is Result.Ok _ {
        Result.Ok v = result; v
    } else if result is Result.Error Match _ {
        match_function value (tail branches)
    } else if result is Result.Error _ {
        -- a different error occurred, so we re-raise it
        Result.Error e = result; error e
    }
}
</code></pre>
<p>I know the use of <code>if</code> to handle tasks that pattern matching excels at hurts a little, but remember, <em>that's why we're building a match expression!</em> Using base constructs to create higher-level affordances with little overhead is a core theme of Passerine development.</p>
<p>Here's how you could use <code>match_function</code>, by the way:</p>
<pre><code class="language-elm">-- Note that we're passing a list of functions
description = match_function Banana (&quot;yellow&quot;, &quot;soft&quot;) [
    Banana (&quot;brown&quot;, &quot;mushy&quot;) -&gt; &quot;That's not my banana!&quot;,

    Banana (&quot;yellow&quot;, flesh)
        | flesh != &quot;soft&quot;
        -&gt; &quot;I mean it's yellow, but not soft&quot;,

    Banana (peel, &quot;soft&quot;)
        | peel != &quot;yellow&quot;
        -&gt; &quot;I mean it's soft, but not yellow&quot;,

    Banana (&quot;yellow&quot;, &quot;soft&quot;) -&gt; &quot;That's my banana!&quot;,

    Banana (color, texture)
        -&gt; &quot;Hmm. I've never seen a { texture } { color } banana before...&quot;,
]
</code></pre>
<p>This is already orders of magnitude better, but passing a list of functions still feels a bit... hacky. Let's use our <code>match</code> macro definition from earlier to make this more ergonomic:</p>
<pre><code class="language-elm">syntax 'match value { arms... } {
    match_function value arms
}
</code></pre>
<p>We've added match expression to Passerine, and they already feel like language features*! Isn't that incredible? Here's the above example we used with <code>match_function</code> adapted to <code>match</code>†:</p>
<pre><code class="language-elm">description = match Banana (&quot;yellow&quot;, &quot;soft&quot;) {
    Banana (&quot;brown&quot;, &quot;mushy&quot;) -&gt; &quot;That's not my banana!&quot;

    Banana (&quot;yellow&quot;, flesh)
        | flesh != &quot;soft&quot;
        -&gt; &quot;I mean it's yellow, but not soft&quot;

    Banana (peel, &quot;soft&quot;)
        | peel != &quot;yellow&quot;
        -&gt; &quot;I mean it's soft, but not yellow&quot;

    Banana (&quot;yellow&quot;, &quot;soft&quot;) -&gt; &quot;That's my banana!&quot;

    Banana (color, texture)
        -&gt; &quot;Hmm. I've never seen a { texture } { color } banana before...&quot;
}
</code></pre>
<blockquote>
<p>† Plot twist: we just defined the <code>match</code> expression we've been using throughout this entire overview.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<p>Passerine's module system allows large codebases to be broken out into indiviual reusable components. A module is a scopes turned into a struct, and isn't necessarily tied to the file system.</p>
<p>Modules are defined using the <code>mod</code> keyword, which must be followed by a block <code>{ ... }</code>. Here's a simple module that defines some math utilities:</p>
<pre><code class="language-elm">circle = mod {
    PI     = 3.14159265358979
    area   = r -&gt; r * r * PI
    circum = r -&gt; r * PI * 2
}

pizza_radius = 12
slices = 8
slice_area = (circle::area pizza_radius) / slices
</code></pre>
<p><code>mod</code> takes all top-level declarations in a block - in this case, <code>PI</code>, <code>area</code>, and <code>circum</code> - and turns them into a struct with those fields. In essence, the above is equivalent to this struct:</p>
<pre><code class="language-elm">circle = {
    PI:     3.14159265358979
    area:   r -&gt; r * r * PI
    circum: r -&gt; r * PI * 2
}
</code></pre>
<p><code>mod</code> is nice because it's an easy way to have multiple returns. In essesence, the <code>mod</code> keyword allows for first-class scoping, by turning scopes into structs:</p>
<pre><code class="language-elm">index = numbers pos
    -&gt; floor (len numbers * pos)

quartiles = numbers -&gt; mod {
    sorted = (sort numbers)
    med = sorted::(index (1/2) sorted)
    q1  = sorted::(index (1/4) sorted)
    q3  = sorted::(index (3/4) sorted)
}
</code></pre>
<p>Because we used the <code>mod</code> keyword in the above example, instead of returning a single value from the function, we return a struct containing all values in the fuction:</p>
<pre><code class="language-elm">-- calculate statistics
numbers = [1, 2, 3, 4, 5]
stats   = quartiles numbers

-- use `q1` and `q3` to calculate the interquartile range of `numbers`
iqr     = stats::q3 - stats::q1
print &quot;the IQR of { numbers } is { iqr } &quot;
</code></pre>
<p>This is really useful for writing functions that return multiple values.</p>
<p>Aside from allowing us to group sets of related values into a single namespace, modules can be defined in different files, then be imported. Here's a module defined in a different file:</p>
<pre><code class="language-elm">-- list_util.pn
reduce = f start list -&gt; match list {
    [] -&gt; start,
    [head, ..tail] -&gt; f (reduce f tail, head)
}

sum     = reduce { (a, b) -&gt; a + b   } 0
reverse = reduce { (a, b) -&gt; [b.., a]} []
</code></pre>
<p>This file defines a number of useful list utilities, defined in a traditional recursive style. If we want to use this module in <code>main.pn</code>, we import it using the <code>use</code> keyword:</p>
<pre><code class="language-elm">-- main.pn
use list_util

numbers = [1, 1, 2, 3, 5]
print (list_util::sum numbers)
</code></pre>
<p>Note that the <code>use</code> keyword is essentially the same thing as wrapping the contents of the imported file with the <code>mod</code> keyword:</p>
<pre><code class="language-elm">-- use list_util
list_util = mod { &lt;list_util.pn&gt; }
</code></pre>
<p>Once imported, <code>list_util</code> is just a struct. Because of this, features of the module system naturally arise from Passerine's existing semantics for manipulating structs. To import a subset of a module, we can do something like this:</p>
<pre><code class="language-elm">reverse = { use list_util; list_util::reduce }
</code></pre>
<p>Likewise, we can import a module within a block scope to rename it:</p>
<pre><code class="language-elm">list_stuff = { use list_util; list_util }
</code></pre>
<p>There are a number of nice properties that arise from this module system, we've just scratched the surface. As modules are just structs, the full power of passerine and its macro system are at your disposal for building extensible systems that compose well.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="concluding-thoughts"><a class="header" href="#concluding-thoughts">Concluding Thoughts</a></h2>
<p>Thanks for reading this far. Passerine has been a joy for me to work on, and I hope you find it a joy to use.</p>
<p>A few of the features discussed in this overview haven't been implemented yet. We're not trying to sell you short, it's just that developing a programming language and bootstrapping a community around it at the same time is not exactly <em>easy</em>.</p>
<p>If you'd like something added to Passerine, open an issue or pull request, or check out the <a href="https://github.com/vrtbl/passerine/projects/1">Project Roadmap</a> to get a feel for what's currently under development.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Contributions are welcome!
Read our <a href="https://github.com/vrtbl/passerine/blob/master/CONTRIBUTING.md">Contribution Guide</a>
and join the <a href="https://discord.gg/yMhUyhw">Discord server</a>
to get started!</p>
<p>If you'd like to contribute to the project but don't have much time to spare, consider <a href="https://www.patreon.com/slightknack">donating</a>. Thank you!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<p><strong>Q:</strong> Is Passerine ready for production use?</p>
<p><strong>A:</strong> Not yet. Passerine is still in early stages of development, with frequent breaking changes. See the <a href="https://github.com/vrtbl/passerine/projects/1">Project Roadmap</a> to get an idea of what's in development.</p>
<p><strong>Q:</strong> Is Passerine statically typed?</p>
<p><strong>A:</strong> Currently, Passerine is strongly and dynamically¹ typed (technically structurally typed). This is partially out of necessity – Types are defined by patterns, and patterns can be where predicated. However, I've been doing a lot of research into Hindley-Milder type systems, and the various extensions that can be applied to them.</p>
<p>I'm working towards making a compile-time type-checker for the language, based on Hindley-Milner type inference. With this system in place, I can make some assumptions to speed up the interpreter further and perhaps monomorphize/generate LLVM IR / WASM.</p>
<p>This type checker is actually the target of the next release, so stay tuned!</p>
<p><strong>Q:</strong> What about algebraic effects and kind-based macros?</p>
<p><strong>A:</strong> I'm interested in eventually adding both these things to the language, but first I need to implement a nice type-checker and do some more research. Algebraic Effects would fill the design space of fibers, and kind based macros would provide a more solid base for passerine's macro system. Got any fresh language features you think would complement Passerine's design philosophy? Reach out!</p>
<p><strong>Q:</strong> What is vaporization memory management?</p>
<p><strong>A:</strong> When I was first designing Passerine, I was big into automatic compile-time memory management. Currently, there are a few ways to do this: from Rust's borrow-checker, to µ-Mitten's Proust ASAP, to Koka's Perceus, there are a lot of new and exciting ways to approach this problem.</p>
<p>Vaporization is an automatic memory management system that allows for <em>Functional but in Place</em> style programming. For vaporization to work, three invariants must hold:</p>
<ol>
<li>All functions params are passed by value via a copy-on-write reference. This means that only the lifetimes of the returned objects need to be preserved, all others will be deleted when they go out of scope.</li>
<li>A form of SSA is performed, where the last usage of any value is not a copy of that value.</li>
<li>All closure references are immutable copies of a value. These copies may be reference-counted in an acyclical manner.</li>
</ol>
<p>With these invariants in place, vaporization ensures two things:</p>
<ol>
<li>Values are only alive where they are still <em>useful</em>.</li>
<li>Code may be written in a functional style, but all mutations occur in-place as per rule 2.</li>
</ol>
<p>What's most interesting is that this system requires minimal interference from the compiler when used in conjunction with a VM. All the compiler has to do is annotate the last usage of the value of any variables; the rest can be done automatically and very efficiently at runtime.</p>
<p>Why not use this? Mainly because of rule 3: 'closure references are immutable'. Passerine is pass-by-value, but currently allows mutation in the current scope a la let-style redefinition. But this is subject to change; and once it does, it's vaporization all the way, baby!</p>
<p><strong>Q:</strong> Aren't there already enough programming languages?</p>
<p><strong>A:</strong> Frankly, I think we've barely <em>scratched</em> the surface of programming language design. To say that Programming Language Design is saturated and at a local maxima is to not understand the nature of software development. Passerine is largely a test as to whether I can build a modern compiler pipeline. But what I'm even more interested in is the tooling that surrounds development environments.</p>
<p>Case in point: text-based entry for programming languages has been around forever because it's fast. However, it's not always semantically correct. The number of correct programs is an infinity smaller than the number of possible text files. Yet it's still possible to make text-based entry systems that ensure semantic correctness while encouraging exploration. In the future, we need to develop new tools that more closely blur the line between language and environment. Pharo is a step in the right direction, as are Unison and similar efforts.</p>
<p>I'd like to focus more on this in the future. An interesting project would be an editor/environment like Pharo/Unison for a small minimal language, like Scheme, or perhaps even Passerine.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
